Collection functionality
	(not include methods that auto come through with Object)
	everything with Set or List(List has also add func)
	Map are not inherited from Collection.

	boolean add(T)-ensures that the container holds the arg which is of generic type T. Return FALSE if it doesn;t add the argument
	boolean addAll(Collection<? extends T>)- adds all the elements in the argument. Return true if any elements were added.
	void clear() - removes all the elements in the container.
	boolean contains(T)- true if the container holds the argument which is of generic type T
	Boolean containsAll(Colleciton<?>)-true if the container holds the argument which is of generic type T.
	boolean isEmpty() - true if the container has no elements.
	Iterator<T> iterator()-returns an Iterator<T> that you can use to move through the elements in the container.
	Boolean remove(Object) - if the arg is in the container, one instance of that element is removed.Returns TRUE if a removal occured.
	boolean removeAll(Collection<?>) -removes all the elements that are contained in the arg. Retrus true if any removals occured.
	Boolean retailAll(Colleciton<?> - retains only elements that are contained in the argument(an "intersection", from set threory)). Returns true if any changes occured.
	int size() - returns the number of the lements in the container
	Object[] toArray() - return an array containing all the lements in the container
	<T>T[] toArray(T[] a)-Returns an array containing all the elements in the container. The runtime type of the result is that of the argument array arather than plain Object.

SET(interface) - each element that you add to the SET must be unique; otherwise the SET doesn't add the duplicate element; Elements added to a Set must at least define equals() to establish object uniqueness. Set has exactly the same interface as Collection. The Set interface does not guarantee that it will maintain its elements in any particular order

HashSet - for Sets where fast lookup time is important. Elements must also define hashCode();

TreeSet - an ordered Set backed by a tree. This way you can extract an ordered sequence from a Set. Elements must also implement the Comparable interface

LinkedHashSet - Has the lookup speed of a HashSet, but internally maintains the order in which you add the elements(the insertion order) using a linked list. Thus, when you iterate through the Set, the results appear in insertion order. Elements must also define hashCode();

equals() -for both hashed and tree storage.
hashCode() - necessary only if the class will be placedd in a HashSet or LinkedHashSet

for good programming style you shoud always override hashCode()



	

